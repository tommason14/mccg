 # Basics of Python

Bored of repeating the same tasks again and again? Let the computer do the work, make your life easier and free up time for more interesting tasks.

Python is widely applicable to a variety of tasks, from web-development to data science to file I/O operations.

We will use Python to automate tasks needed to be performed frequently in computational chemistry.

> This tutorial is valid for Python 3.6 or later.

 ## Fundamental data types

An important concept in Python is that everything is an object, with a type. To find out what kind of object you are dealing with, use the function `type()`.

To be able to pass information around in Python, that data needs to be stored in a variable, using the `=` sign:
```
>>> var = 'Here is a sentence.'
>>> var
'Here is a sentence.'
```

Text is entered as a `string` using quotation marks:

```python
>>> text = 'This is a string'
>>> type(text)
<class 'str'>
```

Strings can be joined together, or concatenated with the `+` operator:
```python
>>> more_text = 'of more text'
>>> text + more_text
'This is a stringof more text'
```
Notice that no spaces are added when strings are concatenated. To fix this, simply add a space that is placed in between quotation marks:

```python
>>> text + ' ' +  more_text
'This is a string of more text'
```
Or print the text in a formatted string, known as an f-string, with variables printed using curly braces:
```python
>>> print(f'{text} {more_text}')
This is a string of more text
```

Whole numbers are known as integers, with decimals called floats, as
they contain floating point values. As you would expect, basic mathematical operations are supported 'out of the box', and integers and floats can be combined in the same expression:

```python
>>> integer1 = 1
>>> integer2 = 4
>>> float1 = 0.2
>>> float2 = 2.0
>>> integer1 + integer2
5
>>> float1 + float2
2.2
>>> integer2 * float2
8.0
>>> integer2 / float2
2.0
>>> integer2 - integer1
3
```

## Data structures

Variables are useful, but let's say you wanted to store multiple items together. Lists can be used to achieve this, written using square brackets:

```python
>>> lst = [1, 2, 3, 4, 5]
>>> type(lst)
<class 'list'>
```
Properties of lists can be found using functions that were written to be applied to them. For example, to find how many items are stored in a list, use the function `len()`:

```python
>>> len(lst)
3
```

To access items, or elements, of each list, square bracket notation is used. Note that 'zero-indexing' is used in Python, with the first element in the list located at the 0th position:
```python
>>> lst[0]
1
>>> lst[2]
3
```

Lists can be sliced to select a subset of the array. The syntax is as follows: `lst[start : end]`, selecting items from `start` up to but not including the `end`:
```python
>>> lst[:3] # first three items
[1, 2, 3]
>>> lst[2:4]
[3, 4] 
```

Lists can be added together with the `+` sign:
```python
>>> [1, 2, 3] + [7, 8, 9]
[1, 2, 3, 7, 8, 9]
```

To add things to the end of a list, use the `append` method, modifying the original list in place:
```python
>>> first = [1, 2, 3]
>>> second = 4
>>> first.append(second)
>>> first
[1, 2, 3, 4]
```

Watch out for unexpected behaviour. If you want to take the list `items = [1, 2, 3]` and multiply every item by 3, you might tempted to do this:

```python
>>> items = [1, 2, 3] 
>>> items * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
```

However this just takes the contents of the list and repeats it three times...

To do this, we have to move through the list and multiply each item as we go.

Use a loop!

Every data structure in Python that contains multiple items can be 'iterated' over using a `for` loop, with the syntax

```python
for item in iterable:
  do_something_with_the_item()
```

Now, to multiple every item of the `items` list by 3:

```python
>>> for item in items:
...     multiple = item * 3
...     print(multiple)
...
3
6
9
```

But the original list still contains the original values! The multiples need to be added to a new list:

```python
>>> items
[1, 2, 3] # The loop didn't change the original values

>>> multiples = []
>>> for item in items:
...     multiple = item * 3
...     multiples.append(multiple)
...
>>> multiples
[3, 6, 9]
```

List comprehensions are a nice way to achieve the same thing with less typing:

```python
>>> multiples = [x * 3 for x in items]
>>> multiples
[3, 6, 9]
>>>
```

Sometimes it useful to get the index of each item. This can be done using the length of list, or the `enumerate` method:
```python
>>> lst = ['One', 'Two', 'Three']
>>> for index in range(len(lst)):
...     print(index, lst[index])
...
0 One
1 Two
2 Three
```

or

```python
>>> for index, item in enumerate(lst):
...     print(f"Index {index} -> {item}")
...
Index 0 -> One
Index 1 -> Two
Index 2 -> Three
```

The enumerate function actually returns a generator object (see later), with each index and item contained in a tuple:
```python
>>> enumerate(lst)
<enumerate object at 0x106feaaf8>
>>> list(enumerate(lst))
[(0, 'One'), (1, 'Two'), (2, 'Three')]
```

Lists are mutable data types, where items in the list can be modified after being added to the list. Tuples are similar, but immutable- once a tuple is created, it cannot be changed. This can be useful when dealing with large amounts of data, and python runs faster when using tuples over lists. Tuples are assigned with parentheses:

```python
>>> tup = (1, 2, 3)
```

Tuples are also iterable:

```python
>>> for num in tup:
...     print(num)
...
1
2
3
```

Sometimes you may want to store data and refer to it later using another variable. For example, the names and ages of people. This can be done using a list of lists:

```python
>>> people = [['John', 35], ['Gemma', 50], ['David', 25]]
```

To get the names of each person:

```python
>>> for person in people:
...     print(person[0])
...
John
Gemma
David
```

This works but there is no indication of what `person[0]` refers to.

A better way is to use a dictionary. A dictionary uses key-value pairs, where the key can be used to refer to values at a later time. Create a dictionary using curly braces and separate keys from their values with a colon:

```python
>>> people = {'John': 35, 'Gemma': 50, 'David': 25}
>>> for name in people:
...     print(name)
...
John
Gemma
David
```

Much clearer! Ages can be accessed with the `values` method:

```python
>>> for age in people.values():
...     print(age)
...
35
50
25
```

But wouldn't it be good to access both names and ages. This can be done with the `items` method:
```python
>>> for name, age in people.items():
...     print(name, age)
...
John 35
Gemma 50
David 25
```

Lists and dictionaries can also be combined. Using a list of dictionaries, the names of each person will be stored as values with the key `name`, same with their ages:

```python

>>> people = [{'name': 'John' , 'age': 35}, 
              {'name': 'Gemma', 'age': 50},
              {'name': 'David', 'age': 25}]

>>> for person in people:
...     print(f"{person['name']} is {person['age']} years old")
...
John is 35 years old
Gemma is 50 years old
David is 25 years old
```

## Conditional statements

Conditional statements let us dictate what we would like to happen in a situation where two results can occur. If you want to see if one number is less than another:

```python
>>> num1 = 10
>>> num2 = 5
>>> if num2 < num1:
...     print('True')
...
True
```

Multiple conditions can be placed together in the same block:

```python
>>> if num1 < num2:
...     print('num1 is less than num2')
... elif num1 == num2: # else if
...     print('num1 is equal to num2')
... else:
...     print('num1 is greater than num2')
...
num1 is greater than num2
```

The `while` loop can be used together with conditional statements like so:
```python
>>> while num2 < num1:
...     print('num2 = ', num2)
...     num2 += 1 # add one to num2
...
num2 =  5
num2 =  6
num2 =  7
num2 =  8
num2 =  9
```

When `num2` was set to 10, Python broke out of the loop.

## Functions

Writing 'procedural' code, line by line, can quickly get very confusing. A clearer way to layout code involves writing functions, pieces of code that can be re-used multiple times.

For example, let's say we have an xyz file with the following lines:

```
C  13.456 12.321 13.054
H  11.222 12.542 10.342
H  10.321  9.896  5.341
O   3.451  5.759  4.531
N   8.421  9.582 10.888
```

and we want to add atomic numbers to every atom. You could write something like this:

```python
atnums = {}
atnums['C'] = 6.0
atnums['H'] = 1.0
atnums['N'] = 7.0
atnums['O'] = 8.0

lines = []

with open(coords.xyz, 'r') as f:
    for line in f:
        lines.append(line)

new_coords = []
for line in lines:
    sym, x, y, z = line.split()
    atnum = atnums[sym]
    new_coords.append(f"{sym:<2} {atnum:<4} {x:<6} {y:<6} {z:<6}\n") #string formatting

with open(coords_modified.xyz)
print(new_coords)

Output:
C  6.0  13.456 12.321 13.054
H  1.0  11.222 12.542 10.342
H  1.0  10.321 9.896  5.341
O  8.0  3.451  5.759  4.531
N  7.0  8.421  9.582  10.888
```

This block defines a dictionary of atomic numbers for carbon, hydrogen, nitrogen and oxygen, splits a multi-line string into coordinates for each atom, finds the corresponding atomic number, adds the number into the line, appends the new line to the `new_coords` list, then prints out the new list.

The code can be re-written using functions for clarity:
```python

def read_file(file): 
    lines = []
    with open(file, 'r') as f:
        for line in f:
            lines.append(line)
    return lines

def get_atomic_number(symbol):
    atnums = {}
    atnums['C'] = 6.0
    atnums['H'] = 1.0
    atnums['N'] = 7.0
    atnums['O'] = 8.0

    return atnums[symbol]    

def add_atomic_number(line):    
    sym, x, y, z = line.split()
    atnum = get_atomic_number(sym) 
    return f"{sym:<2} {atnum:<4} {x:<6} {y:<6} {z:<6}\n"

def modify_coords(coords):
    new_coords = []
    for line in coords:
        line = add_atomic_number(line)
        new_coords.append(line)
    return new_coords

def write_file(filename, lst):
    print(''.join(file))

def main():
    coords = read_file(file)
    new_coords = modify_coords(coords)
    write_file(filename, new_coords)

main()

Output:
C  6.0  13.456 12.321 13.054
H  1.0  11.222 12.542 10.342
H  1.0  10.321 9.896  5.341 
O  8.0  3.451  5.759  4.531 
N  7.0  8.421  9.582  10.888
```

In this example, the code using functions is longer than the procedural
version, but now we can re-use the code! The function `modify_coords` can be
used to modify 1000 xyz files in one go if we wanted to:

```python

lst = [file1, file2, file3...]

for file in lst:
    coords = read_file(file)
    new_coords = modify_coords(coords)
    write_file(new_coords)
```

It's that easy!

